import prisma from '../../lib/prisma.js';
import * as cheerio from 'cheerio';
import { info, error as logError } from '../../lib/logger.js';
import { ImporterServiceV2 } from './ImporterServiceV2.js';
import { downloadMedia, processHtmlMedia } from '../mediaService.js';

/**
 * TransformationEngine applies the generated ruleset to staged items
 * to create actual CMS content and templates.
 */
export class TransformationEngine {
  constructor(siteId, dbName) {
    this.siteId = siteId;
    this.dbName = dbName;
  }

  async run() {
    try {
      info(this.dbName, 'IMPORT_V2_TRANSFORM_START', `Starting transformation for site ${this.siteId}`);

      const site = await prisma.imported_sites.findUnique({
        where: { id: this.siteId }
      });

      if (!site || !site.llm_ruleset) throw new Error('Ruleset not found');
      const ruleset = site.llm_ruleset;
      const rootOrigin = new URL(site.root_url).origin;

      // 1. Process each crawled page
      const items = await prisma.staged_items.findMany({
        where: { site_id: this.siteId, status: 'crawled' }
      });

      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const groupRules = ruleset.types?.[item.structural_hash];
        if (!groupRules || !groupRules.selector_map) continue;

        if (i % 10 === 0) {
          await ImporterServiceV2.updateStatus(this.siteId, 'transforming', `Migrating items to CMS ${i + 1}/${items.length}...`);
        }

        info(this.dbName, 'IMPORT_V2_TRANSFORM_ITEM', `Transforming ${item.url} using ${groupRules.page_type} selectors`);

        // --- LOCAL EXTRACTION (Using selectors generated by AI earlier) ---
        const extractedContent = await this.performLocalExtraction(item.stripped_html, groupRules.selector_map);

        // Map page_type to CMS module
        let moduleName = 'pages';
        if (groupRules.page_type === 'product') moduleName = 'products';
        if (['article', 'blog_post', 'post'].includes(groupRules.page_type)) moduleName = 'posts';

        // --- Sideload Media & Remap Links ---
        for (const [key, value] of Object.entries(extractedContent)) {
          if (!value) continue;

          // 1. Handle Richtext (Images and internal Links)
          if (typeof value === 'string' && (value.includes('<img') || value.includes('<a'))) {
            let processed = await processHtmlMedia(value);
            // Remap internal absolute links to relative slugs
            processed = processed.replace(new RegExp(rootOrigin, 'g'), '');
            extractedContent[key] = processed;
          }

          // 2. Handle specific image fields
          else if (key === 'image' || key === 'thumbnail' || key === 'featured_image') {
            if (typeof value === 'string' && value.startsWith('http')) {
              extractedContent[key] = await downloadMedia(value, extractedContent.title || item.title);
            }
          }

          // 3. Handle galleries/arrays
          else if (Array.isArray(value)) {
            extractedContent[key] = await Promise.all(value.map(async (v) => {
              if (typeof v === 'string' && v.startsWith('http')) {
                return await downloadMedia(v, extractedContent.title || item.title);
              }
              return v;
            }));
          }
        }

        // Save to CMS content table (Upsert based on slug derived from source_url)
        const slug = this.generateSlug(item.url);
        const content = await prisma.content.upsert({
          where: { slug: slug },
          update: {
            module: moduleName,
            title: extractedContent.title || item.title,
            data: extractedContent,
            source_url: item.url,
            updated_at: new Date()
          },
          create: {
            module: moduleName,
            title: extractedContent.title || item.title,
            slug: slug,
            data: extractedContent,
            source_url: item.url
          }
        });

        // --- Create/Update Module Specific Record ---
        const templateId = groupRules.template_id;
        
        let cleanPrice = 0;
        if (extractedContent.price) {
          const priceStr = String(extractedContent.price).replace(/[^\d.]/g, '');
          cleanPrice = parseFloat(priceStr) || 0;
        }
        
        if (moduleName === 'pages' || moduleName === 'posts') {
          // Find existing page manually since relation is removed
          const existingPage = await prisma.pages.findFirst({
            where: { content_id: content.id }
          });

          await prisma.pages.upsert({
            where: { id: existingPage?.id || -1 },
            update: { 
              title: content.title, 
              template_id: templateId, 
              status: 'published',
              content_type: moduleName 
            },
            create: { 
              content_id: content.id, 
              title: content.title, 
              template_id: templateId, 
              status: 'published',
              content_type: moduleName
            }
          });
        } 
        else if (moduleName === 'products') {
          await prisma.products.upsert({
            where: { sku: extractedContent.sku || `slug-${content.slug}` },
            update: { 
              title: content.title, 
              template_id: templateId, 
              price: cleanPrice,
              status: 'active'
            },
            create: { 
              content_id: content.id, 
              title: content.title, 
              template_id: templateId, 
              sku: extractedContent.sku || `slug-${content.slug}`,
              price: cleanPrice,
              status: 'active'
            }
          });
        }

        // Link staged item to content
        await prisma.staged_items.update({
          where: { id: item.id },
          data: { status: 'transformed', metadata: { ...item.metadata, content_id: content.id } }
        });
      }

      await ImporterServiceV2.updateStatus(this.siteId, 'completed', 'Transformation and Media sideloading complete!');
      info(this.dbName, 'IMPORT_V2_TRANSFORM_COMPLETE', `Transformation finished for ${items.length} items`);

    } catch (err) {
      logError(this.dbName, err, 'IMPORT_V2_TRANSFORM_FAILED');
      throw err;
    }
  }

  /**
   * Extract content using CSS selectors (Cheerio)
   */
  async performLocalExtraction(html, selectorMap) {
    const $ = cheerio.load(html);
    const results = {};

    for (const [field, selector] of Object.entries(selectorMap)) {
      if (!selector) continue;
      const $el = $(selector);
      if ($el.length === 0) continue;

      if (field === 'image' || field === 'images' || field === 'gallery' || field === 'thumbnail') {
        const images = $el.map((i, el) => {
          const src = $(el).attr('src') || $(el).attr('data-src') || $(el).attr('href');
          if (src && src.startsWith('//')) return 'https:' + src;
          return src;
        }).get().filter(Boolean);
        results[field] = (field === 'images' || field === 'gallery') ? images : images[0];
      } 
      else if (['description', 'content', 'body', 'richtext', 'main', 'article', 'post'].includes(field)) {
        results[field] = $el.html()?.trim();
      } 
      else {
        // Fallback: If the field name doesn't match but the content has tags, it's probably HTML
        const html = $el.html()?.trim();
        if (html && (html.includes('<p') || html.includes('<div') || html.includes('<br'))) {
          results[field] = html;
        } else {
          results[field] = $el.first().text().trim();
        }
      }
    }
    return results;
  }

  generateSlug(url) {
    try {
      const path = new URL(url).pathname;
      if (path === '/' || !path) return 'home';
      
      // Preserve the full path without replacing slashes with dashes
      // But ensure it starts with a slash
      return path.startsWith('/') ? path : '/' + path;
    } catch {
      return 'item-' + Date.now();
    }
  }
}
